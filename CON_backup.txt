      "upload_processed",
      "upload_failed",
    ].includes(type)
  ) {
    return "medium";
  }
  return "low";
}

function condenseList(list, limit = 2) {
  const uniq = Array.from(new Set((list || []).filter(Boolean)));
  if (!uniq.length) return "";
  if (uniq.length <= limit) return uniq.join(", ");
  const tail = uniq.slice(-limit);
  return `${tail.join(", ")} (+${uniq.length - limit} more)`;
}

function queueLiveEvent(type, detail = {}, lane = "orch") {
  const severity = eventSeverity(type);
  const urls = [];
  if (detail.url) urls.push(detail.url);
  if (Array.isArray(detail.urls)) urls.push(...detail.urls);
  liveEventBuffer.push({ type, detail, lane, severity, urls });
  if (SEVERITY_RANK[severity] >= SEVERITY_RANK.medium) {
    flushLiveEvents();
  } else {
    scheduleLiveFlush();
  }
}

function queueLiveNote(note, lane = "orch") {
  if (!note) return;
  queueLiveEvent("client_note", { note }, lane);
}

function scheduleLiveFlush() {
  if (liveFlushTimer) return;
  liveFlushTimer = setTimeout(() => flushLiveEvents(), 2000);
}

function summarizeLiveEvents(events) {
  const stats = {
    searches: 0,
    searchQueries: [],
    extracts: 0,
    stepsStarted: [],
    stepsCompleted: [],
    memHits: 0,
    memSaved: 0,
    controls: [],
    loops: 0,
    router: null,
    planSteps: null,
    strict: false,
    finished: null,
    errors: [],
    warnings: [],
    notes: [],
    question: "",
    urls: [],
    uploads: [],
  };
  let lane = "orch";
  (events || []).forEach((ev) => {
    if (ev.lane) lane = ev.lane;
    if (Array.isArray(ev.urls)) stats.urls.push(...ev.urls);
    const d = ev.detail || {};
    switch (ev.type) {
      case "run_started":
        stats.question = d.question || stats.question || pendingQuestion;
        break;
      case "router_decision":
        stats.router = d;
        break;
      case "plan_created":
        stats.planSteps = Number(d.steps || stats.planSteps || 0);
        break;
      case "step_started":
        stats.stepsStarted.push(d.name || (d.step_id ? `Step ${d.step_id}` : "Step started"));
        break;
      case "step_completed":
        stats.stepsCompleted.push(d.name || (d.step_id ? `Step ${d.step_id}` : "Step completed"));
        break;
      case "tavily_search":
        stats.searches += 1;
        if (d.query) stats.searchQueries.push(d.query);
        break;
      case "tavily_extract":
        stats.extracts += d.urls && d.urls.length ? d.urls.length : 1;
        break;
      case "tavily_error":
        stats.errors.push(d.message || "Tavily search unavailable");
        break;
      case "memory_retrieved":
        stats.memHits += Number(d.count || 0);
        break;
      case "memory_saved":
        stats.memSaved += Number(d.count || 0);
        break;
      case "control_action":
        if (d.control || d.action_type) stats.controls.push(d.control || d.action_type);
        break;
      case "loop_iteration":
        stats.loops += 1;
        break;
      case "strict_mode":
        stats.strict = true;
        break;
      case "archived":
        stats.finished = d;
        break;
      case "error":
        if (d.message) stats.errors.push(d.message);
        break;
      case "step_error": {
        const label = d.name || (d.step ? `Step ${d.step}` : "Step");
        const msg = d.message || "error";
        stats.warnings.push(`${label}: ${msg}`);
        break;
      }
      case "upload_received":
        stats.uploads.push(d.name || `Upload ${d.upload_id || ""}`);
        break;
      case "upload_processed":
        stats.uploads.push(d.name || `Upload ${d.upload_id || ""}`);
        if (d.summary) stats.notes.push(`Upload: ${d.summary}`);
        break;
      case "upload_failed":
        stats.errors.push(d.error || `Upload failed: ${d.name || ""}`);
        break;
      default:
        break;
    }
    if (d.note && !stats.notes.includes(d.note)) {
      stats.notes.push(d.note);
    }
  });
  if (!stats.question && pendingQuestion) {
    stats.question = pendingQuestion;
  }
  const hasErrors = stats.errors.length > 0;
  const hasWarnings = stats.warnings.length > 0;
  let tone = hasErrors ? "error" : hasWarnings ? "warn" : "info";
  const parts = [];
  const usedQuestion = !!(stats.question && !questionShownInLive);
  if (usedQuestion) parts.push(`Plan: ${stats.question}`);
  if (stats.router) {
    const r = stats.router;
    const tier = r.model_tier ? ` ${tierLabel(r.model_tier)}` : "";
    const web = r.needs_web ? " + web" : "";
    const max = r.max_results ? ` max ${r.max_results}` : "";
    const route = r.deep_route ? ` route:${r.deep_route}` : "";
    parts.push(`Router${tier} ${r.reasoning_level || ""}${web}${max}${route}`.trim());
  }
  if (stats.uploads.length) parts.push(`Uploads: ${condenseList(stats.uploads, 3)}`);
  if (stats.strict) parts.push("Strict verify on");
  if (stats.planSteps !== null && stats.planSteps !== undefined) parts.push(`${stats.planSteps} step plan`);
  const started = condenseList(stats.stepsStarted);
  if (started) parts.push(`â–¶ ${started}`);
  const completed = condenseList(stats.stepsCompleted);
